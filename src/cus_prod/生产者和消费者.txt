http://v.youku.com/v_show/id_XMTI2Mzk2MDk4OA==.html?spm=a2h0j.11185381.listitem_page1.5!8~A&f=25849527

/***
 * 不通种类的线程针对同一个资源的操作,如果在每个线程中使用或者创建不通的资源，那就不会造成抢资源现象
 *
 * 资源类：Student
 * 设置学生数据：SetThread 生产者
 * 获取学生数据：GetThread 消费者
 * 测试类：Cus_Prod
 *
 * 线程安全问题：
 *  A:是否多线程环境
 *  B:是否有共享数据
 *  C:是否有多条语句操作共享数据
 *
 *  加锁：
 *      不同种类线程都要加锁
 *      不通种类线程要加通一把锁，不能加在两个对象上
 *
 *  生产者：
 *      先看是否有数据，有就等待，没有就生产，生产完之后通知消费者来消费
 *  生产者
 *      先看是否有数据，有就消费，没有就等待，通知生产者生产数据
 *
 *  java：等待唤醒机制
 *
 */

 * java等待唤醒机制
 * object.notify() 唤醒该对象上等待的单个线程,唤醒并不表示可以立即执行，必须还得抢CPU执行权，notify后必须等synchronized语句块执行完毕，才能释放锁，释放锁以后继续随机抢cpu执行权,多个线程都有可能抢到
 * object.notifyAll() 唤醒该对象上等待的所有线程
 * object.wait()  //锁立即被释放





