http://v.youku.com/v_show/id_XMTI2Mzk2MDk4OA==.html?spm=a2h0j.11185381.listitem_page1.5!8~A&f=25849527

/***
 * 不通种类的线程针对同一个资源的操作,如果在每个线程中使用或者创建不通的资源，那就不会造成抢资源现象
 *
 * 资源类：Student
 * 设置学生数据：SetThread 生产者
 * 获取学生数据：GetThread 消费者
 * 测试类：Cus_Prod
 *
 * 线程安全问题：
 *  A:是否多线程环境
 *  B:是否有共享数据
 *  C:是否有多条语句操作共享数据
 *
 *  加锁：
 *      不同种类线程都要加锁
 *      不通种类线程要加通一把锁，不能加在两个对象上
 *
 *  生产者：
 *      先看是否有数据，有就等待，没有就生产，生产完之后通知消费者来消费
 *  生产者
 *      先看是否有数据，有就消费，没有就等待，通知生产者生产数据
 *
 *  java：等待唤醒机制
 *
 */

 * java等待唤醒机制
 * object.notify() 唤醒该对象上等待的单个线程,唤醒并不表示可以立即执行，必须还得抢CPU执行权，notify后必须等synchronized语句块执行完毕，才能释放锁，释放锁以后继续随机抢cpu执行权,多个线程都有可能抢到
 * object.notifyAll() 唤醒该对象上等待的所有线程
 * object.wait()  //锁立即被释放



/**关于生产消费的问题***/
生产日志应放在入队操作之前，否则同一个task的生产日志可能出现在消费日志之后。
// 旧的错误代码
queue.put(task);
System.out.println("produce: " + task.no);
// 正确代码
System.out.println("produce: " + task.no);
queue.put(task);
具体来说，生产日志应放在入队操作之前，消费日志应放在出队操作之后，以保障：
消费线程中queue.take()返回之后，对应生产线程（生产该task的线程）中queue.put()及之前的行为，对于消费线程来说都是可见的。
想想为什么呢？因为我们需要借助“queue.put()与queue.take()的偏序关系”。其他实现方案分别借助了条件队列、锁的偏序关系，不存在该问题。要解释这个问题，需要读者明白可见性和Happens-Before的概念，篇幅所限，暂时不多解释。





